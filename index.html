<!DOCTYPE html>
<html>
<head>
    <title>Scafidi-Ziero-De Reggi: Gengi's Axe</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="css/bootstrap.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" media="screen" href="css/main.css">

    <script src="libs/three.js"></script>
    <script src="libs/stats.min.js"></script>
    <script src="libs/OrbitControls.js"></script>
    <script src='libs/dat.gui.min.js'></script>
    <script src='libs/LoaderSupport.js'></script>
    <script src='libs/OBJLoader2.js'></script>

    <script src='libs/BufferGeometryUtils.js'></script>

</head>



<body>
    <div id="container">
        

        <p align="center"><img src="images/bar.png" width="100%"></p>


      <div>
                <div class="row">
                    <div class="col-1">
                        <img id="uniud" src="images/Uniud.png" width="100%" alt="Logo UNIUD">
                    </div>
                    <div class="col-10">
                        <p class="header">...dall'antica tradizione orientale</p>
                        <p class="title">L'ASCIA DI GENGIS KHAN</p>
                    </div>
                    <div class="col-1">
                        <img id="uniud" src="images/acme_logo.png" width="100%" alt="Logo UNIUD">
                    </div>
                </div>
      </div>

        <div class="row justify-content-md-center">
            <div class="col-2">
                <p class="menuchoice">Modifica il MATERIALE della lama</p>
                    <a href="#" onClick="changeMaterial('argento')"><img class="material" src="images/metal.jpg" alt="argento"></a>
                    <a href="#" onClick="changeMaterial('oro')"><img class="material" src="images/oro.jpg" alt="oro"></a>
                    <a href="#" onClick="changeMaterial('vetro')"><img class="material" src="images/glass.jpg" alt="glass"></a>
                    <a href="#" onClick="changeMaterial('smeraldo')"><img class="material" src="images/emerald.jpg" alt="emerald"></a>
                <p class="menuchoice">Modifica MATERIALE dell'impugnatura</p>
                    <a href="#" onClick="changeMaterial('titanio')"><img class="material" src="images/titanio.jpg" alt="titanio"></a>
                    <a href="#" onClick="changeMaterial('rame')"><img class="material" src="images/rame.jpg" alt="rame"></a>
                    <a href="#" onClick="changeMaterial('legno')"><img class="material" src="images/legno.jpg" alt="legno"></a>                    
                    <a href="#" onClick="changeMaterial('carbonio')"><img class="material" src="images/carbon.jpg" alt="carbonio"></a>
                    
            </div>


            <div class="col-8 h-100">
                <div style="height: 500px;" id="canvas"></div>
                <p class="description" align="center">Hai selezionato: lama in <span id="mat_lama" class="description2">argento</span> con manico in <span id="mat_manico" class="description2">oro</span>.</p>
            </div>


            <div class="col-2">
                <p class="menuchoice">Modifica il BACKGROUND</p>
                    <a href="#" onClick="changeAmbiente('jungle2')"><img class="material" src="images/jungle2.jpg" alt="jungle2"></a>
                    <a href="#" onClick="changeAmbiente('park')"><img class="material" src="images/park.jpg" alt="park"></a>
                    <a href="#" onClick="changeAmbiente('tempio')"><img class="material" src="images/tempio.jpg" alt="tempio"></a>
                    <a href="#" onClick="changeAmbiente('distesa')"><img class="material" src="images/distesa.jpg" alt="distesa"></a>
                    <a href="#" onClick="changeAmbiente('neve')"><img class="material" src="images/neve.jpg" alt="neve"></a>
                    <a href="#" onClick="changeAmbiente('noBack')"><img class="material" src="images/noBack.jpg" alt="noBack"></a>
                <p>&nbsp;</p>
                <p class="menuchoice">Controllo LUCE <br /><span class="fondo">(solo nella vista senza background)</span></p>
                    <a href="#" onClick="changeLight('noLight')"><img class="icona" src="images/icona_luce_off.png" alt="noLight"></a>
                    <a href="#" onClick="changeLight('yesLight')"><img class="icona" src="images/icona_luce.png" alt="yesLight"></a>
                    <a href="#" onClick="changeLight('turnLight')"><img class="icona" src="images/icona_luce_gira.png" alt="turnLight"></a>
            </div>
        </div>



		<script type="text/x-glsl" id="vertex_background">
        attribute vec4 tangent;
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec2 vUv;
        varying vec3 vTangent;
        varying vec3 vBitangent;

        void main() {
            vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
            vPosition = vPos.xyz;
            vNormal = normalize(normalMatrix * normal);
            vec3 objectTangent = vec3( tangent.xyz );
            vec3 transformedTangent = normalMatrix * objectTangent;
            vTangent = normalize( transformedTangent );
            vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
            vUv = uv;
            gl_Position = projectionMatrix * vPos;
        }
        </script>

        <script type="text/x-glsl" id="fragment_background">
            varying vec3 vNormal;
            varying vec3 vTangent;
            varying vec3 vBitangent;
            varying vec3 vPosition;
            varying vec2 vUv;
            uniform vec3 pointLightPosition; // in world space
            uniform vec3 clight;
            uniform vec3 cspec;
            uniform vec3 cdiff;
            uniform float roughness;
            uniform sampler2D normalMap;
            uniform vec2 normalScale;
            const float PI = 3.14159;

            vec3 FSchlick(float lDoth) {
                return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
            }

            float DGGX(float nDoth, float alpha) {
                float alpha2 = alpha*alpha;
                float d = nDoth*nDoth*(alpha2-1.0)+1.0;
                return (  alpha2 / (PI*d*d));
            }

            float G1(float dotProduct, float k) {
                return (dotProduct / (dotProduct*(1.0-k) + k) );
            }

            float GSmith(float nDotv, float nDotl) {
                    float k = roughness*roughness;
                    return G1(nDotl,k)*G1(nDotv,k);
            }


            void main() {
                vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
                vec3 l = normalize(lPosition.xyz - vPosition.xyz);
                vec3 normal = normalize( vNormal );
                vec3 tangent = normalize( vTangent );
                vec3 bitangent = normalize( vBitangent );
                mat3 vTBN = mat3( tangent, bitangent, normal );
                vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
                //mapN.xy = normalScale * mapN.xy;
                vec3 n = normalize( vTBN * mapN );
                vec3 v = normalize( -vPosition);
                vec3 h = normalize( v + l);
                // small quantity to prevent divisions by 0
                float nDotl = max(dot( n, l ),0.000001);
                float lDoth = max(dot( l, h ),0.000001);
                float nDoth = max(dot( n, h ),0.000001);
                float vDoth = max(dot( v, h ),0.000001);
                float nDotv = max(dot( n, v ),0.000001);
                vec3 fresnel = FSchlick(lDoth);
                vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/
                    (4.0*nDotl*nDotv);
                vec3 outRadiance = PI* clight * nDotl * BRDF;
                // gamma encode the final value
                gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
            }
        </script>



        <script type="text/x-glsl" id="vertex">
        attribute vec4 tangent;
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 wPosition;
        varying vec3 vTangent;
        varying vec3 vBitangent;
        varying vec2 vUv;

        void main() {
            vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
            vPosition = vPos.xyz;
            wPosition = (modelMatrix * vec4( position, 1.0 )).xyz;
            vNormal = normalize(normalMatrix * normal);
            vec3 objectTangent = vec3( tangent.xyz );
            vec3 transformedTangent = normalMatrix * objectTangent;
            vTangent = normalize( transformedTangent );
            vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
            vUv = uv;
            gl_Position = projectionMatrix * vPos;
        }
        </script>

        <script type="text/x-glsl" id="fragment">
            varying vec3 vNormal;
            varying vec3 vTangent;
            varying vec3 vBitangent;
            varying vec3 vPosition;
            varying vec3 wPosition;
            varying vec2 vUv;
            uniform vec3 cspec;
            uniform sampler2D normalMap;
            uniform samplerCube envMap;
            uniform vec2 normalScale;
            const float PI = 3.14159;

            vec3 FSchlick(float lDoth) {
                return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
            }

        

        // http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
        vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
            return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
        }

            void main() {
                vec3 normal = normalize( vNormal );
                vec3 tangent = normalize( vTangent );
                vec3 bitangent = normalize( vBitangent );
                mat3 vTBN = mat3( tangent, bitangent, normal );
                vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
                //mapN.xy = normalScale * mapN.xy;
                vec3 n = normalize( vTBN * mapN );
                vec3 v = normalize( -vPosition);
                vec3 worldN = inverseTransformDirection( n, viewMatrix );
                vec3 worldV = cameraPosition - wPosition ;
                vec3 r = normalize( reflect(-worldV,worldN));
                // small quantity to prevent divisions by 0
                float nDotv = max(dot( n, v ),0.000001);
                vec3 fresnel = FSchlick(nDotv);
                // negate x to account for how cubemap is displayed on background
                vec3 envLight = textureCube( envMap, vec3(-r.x, r.yz)).rgb;
                // texture in sRGB, linearize
                envLight = pow( envLight, vec3(2.2));
                vec3 outRadiance = fresnel*envLight;
                // gamma encode the final value
                gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
            }
        </script>


        <script type="text/x-glsl" id="fragment_vetro">
            varying vec3 vNormal;
            varying vec3 vTangent;
            varying vec3 vBitangent;
            varying vec3 vPosition;
            varying vec3 wPosition;
            varying vec2 vUv;
            uniform vec3 cspec;
            uniform sampler2D normalMap;
            uniform samplerCube envMap;
            uniform vec2 normalScale;
            const float PI = 3.14159;

            vec3 FSchlick(float lDoth) {
                return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
            }

        

        // http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
        vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
            return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
        }

            void main() {
                vec3 normal = normalize( vNormal );
                vec3 tangent = normalize( vTangent );
                vec3 bitangent = normalize( vBitangent );
                mat3 vTBN = mat3( tangent, bitangent, normal );
                vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
                //mapN.xy = normalScale * mapN.xy;
                vec3 n = normalize( vTBN * mapN );
                vec3 v = normalize( -vPosition);
                vec3 worldN = inverseTransformDirection( n, viewMatrix );
                vec3 worldV = cameraPosition - wPosition ;
                vec3 r = normalize( refract(-worldV,worldN,(1.0/1.52)));
                // small quantity to prevent divisions by 0
                float nDotv = max(dot( n, v ),0.000001);
                vec3 fresnel = FSchlick(nDotv);
                // negate x to account for how cubemap is displayed on background
                vec3 envLight = textureCube( envMap, vec3(-r.x, r.yz)).rgb;
                // texture in sRGB, linearize
                envLight = pow( envLight, vec3(2.2));
                vec3 outRadiance = fresnel*envLight;
                // gamma encode the final value
                gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
            }
        </script>


        <script type="text/x-glsl" id="fragment_vetro1">
            precision highp float;
            precision highp int;
            varying vec3 vNormal;
            varying vec3 vTangent;
            varying vec3 vBitangent;
            varying vec3 vPosition;
            varying vec2 vUv;
            uniform vec3 cspec;
            uniform sampler2D normalMap;
            uniform samplerCube envMap;
            uniform vec2 normalScale;
            uniform float roughness;

            const float PI = 3.14159;
            #define saturate(a) clamp( a, 0.0, 1.0 )

            float pow2( const in float x ) { return x*x; }

            float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
                float maxMIPLevelScalar = float( maxMIPLevel );
                float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
                return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
            }

            float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
                return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
            }

            // http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
            vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
                return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
            }

            vec3 BRDF_Specular_GGX_Environment( vec3 normal, vec3 viewDir, const in vec3 cspec, const in float roughness ) {

                float dotNV = saturate( dot( normal, viewDir ) );
                const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
                const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
                vec4 r = roughness * c0 + c1;
                float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
                vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
                return cspec * AB.x + AB.y;

            }

            void main() {
                vec3 normal = normalize( vNormal );
                vec3 tangent = normalize( vTangent );
                vec3 bitangent = normalize( vBitangent );
                mat3 vTBN = mat3( tangent, bitangent, normal );
                vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
                //mapN.xy = normalScale * mapN.xy;
                vec3 n = normalize( vTBN * mapN );
                vec3 v = normalize( -vPosition);
                vec3 vReflect = reflect(vPosition,n);
                vec3 r = inverseTransformDirection( vReflect, viewMatrix );

                float blinnShininessExponent = GGXRoughnessToBlinnExponent(roughness);
                float specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent,8 );

                vec3 envLight = textureCubeLodEXT( envMap, vec3(-r.x, r.yz), specularMIPLevel ).rgb;
                // texture in sRGB, linearize
                envLight = pow( envLight, vec3(2.2));
                vec3 outRadiance = envLight*BRDF_Specular_GGX_Environment(n, v, cspec, roughness);
                // gamma encode the final value
                gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
                //gl_FragColor = vec4(r,1.0);
            }
        </script>

        


        <script type="text/x-glsl" id="vertex_legno">
		varying vec3 vNormal;
		varying vec3 vPosition;
		varying vec2 uVv;

		void main() {
			vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
			vPosition = vPos.xyz;
			vNormal = normalMatrix * normal;
			uVv = uv;
			gl_Position = projectionMatrix * vPos;
		}
		</script>

		<script type="text/x-glsl" id="fragment_legno">
			varying vec3 vNormal;
			varying vec3 vPosition;
			varying vec2 uVv;
			uniform vec3 pointLightPosition; // in world space
			uniform vec3 clight;
			uniform sampler2D specularMap;
			uniform sampler2D diffuseMap;
			uniform sampler2D roughnessMap;
			uniform vec2 textureRepeat;
			const float PI = 3.14159;

			vec3 cdiff;
			vec3 cspec;
			float roughness;

			vec3 FSchlick(float lDoth) {
				return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
			}

			float DGGX(float nDoth, float alpha) {
				float alpha2 = alpha*alpha;
				float d = nDoth*nDoth*(alpha2-1.0)+1.0;
				return (  alpha2 / (PI*d*d));
			}

			float G1(float dotProduct, float k) {
				return (dotProduct / (dotProduct*(1.0-k) + k) );
			}

			float GSmith(float nDotv, float nDotl) {
					float k = roughness*roughness;
					return G1(nDotl,k)*G1(nDotv,k);
			}

			void main() {
				vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
				vec3 n = normalize( vNormal );  // interpolation destroys normalization, so we have to normalize
				vec3 v = normalize( -vPosition);
				vec3 h = normalize( v + l);
				// small quantity to prevent divisions by 0
				float nDotl = max(dot( n, l ),0.000001);
				float lDoth = max(dot( l, h ),0.000001);
				float nDoth = max(dot( n, h ),0.000001);
				float vDoth = max(dot( v, h ),0.000001);
				float nDotv = max(dot( n, v ),0.000001);

				cdiff = texture2D( diffuseMap, uVv*textureRepeat ).rgb;
				// texture in sRGB, linearize
				cdiff = pow( cdiff, vec3(2.2));
				cspec = texture2D( specularMap, uVv*textureRepeat ).rgb;
				// texture in sRGB, linearize
				cspec = pow( cspec, vec3(2.2));
				roughness = texture2D( roughnessMap, uVv*textureRepeat).r; // no need to linearize roughness map

				vec3 fresnel = FSchlick(lDoth);
				vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/
					(4.0*nDotl*nDotv);
				vec3 outRadiance = PI* clight * nDotl * BRDF;
				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}
		</script>



		<script type="text/x-glsl" id="vertex_irr">
		attribute vec4 tangent;
		varying vec3 vNormal;
		varying vec3 vPosition;
		varying vec3 wPosition;
		varying vec3 vTangent;
		varying vec3 vBitangent;
		varying vec2 vUv;

		void main() {
			vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
			vPosition = vPos.xyz;
			wPosition = (modelMatrix * vec4( position, 1.0 )).xyz;
			vNormal = normalize(normalMatrix * normal);
			vec3 objectTangent = vec3( tangent.xyz );
			vec3 transformedTangent = normalMatrix * objectTangent;
			vTangent = normalize( transformedTangent );
			vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
			vUv = uv;
			gl_Position = projectionMatrix * vPos;
		}
		</script>

		<script type="text/x-glsl" id="fragment_irr">
			varying vec3 vNormal;
			varying vec3 vTangent;
			varying vec3 vBitangent;
			varying vec3 vPosition;
			varying vec3 wPosition;
			varying vec2 vUv;
			uniform sampler2D diffuseMap;
			uniform sampler2D normalMap;
			uniform samplerCube irradianceMap;
			uniform vec2 normalScale;
			const float PI = 3.14159;

			uniform vec2 textureRepeat;

			vec3 cdiff;

		

		// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
		vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
			return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
		}

			void main() {
				vec3 normal = normalize( vNormal );
				vec3 tangent = normalize( vTangent );
				vec3 bitangent = normalize( vBitangent );
				mat3 vTBN = mat3( tangent, bitangent, normal );
				vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
				//mapN.xy = normalScale * mapN.xy;
				vec3 n = normalize( vTBN * mapN );
				vec3 v = normalize( -vPosition);
				vec3 worldN = inverseTransformDirection( n, viewMatrix );
				vec3 worldV = cameraPosition - wPosition ;
				vec3 r = normalize( reflect(-worldV,worldN));
				// small quantity to prevent divisions by 0
				float nDotv = max(dot( n, v ),0.000001);
				// negate x to account for how cubemap is displayed on background
				vec3 irradiance = textureCube( irradianceMap, worldN).rgb;
				// texture in sRGB, linearize
				irradiance = pow( irradiance, vec3(2.2));
				cdiff = texture2D( diffuseMap, vUv  *textureRepeat).rgb;
				// texture in sRGB, linearize
				cdiff = pow( cdiff, vec3(2.2));
				vec3 outRadiance = cdiff*irradiance;
				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}
		</script>


        

        <script>
            var refreshTime=10; //millisecondi
            var movimento_luce_lastUpdate=0;
            var angololuce=-50;
            var variazioneAngoloLuce = 0;
            var prezzoBastone = 42;
            var prezzoLama = 100;


            container = document.getElementById('canvas');
            larghezza = document.getElementById('canvas').clientWidth -10;
            altezza = document.getElementById('canvas').clientHeight -10;
            console.log("altezza"+altezza);
            console.log("larghezza"+larghezza);
            var renderer = new THREE.WebGLRenderer( { antialias: true } );
            var camera = new THREE.PerspectiveCamera( 35, larghezza / altezza, 1, 1000 );
            var controls = new THREE.OrbitControls( camera, renderer.domElement );
            var scene = new THREE.Scene();

            // default: white, 1.0 intensity
            var lightParameters = {
                red: 1.0,
                green: 1.0,
                blue: 1.0,
                intensity: 1.0,
            }

            var textureParameters = {
                normalScale: 0.0,
            }

            var normalMapI = loadTexture( "modello/textures/Cylinder001 [Normal].png" );
            var normalMapL = loadTexture( "modello/textures/Box002 [Normal].png" );
            var specularMapLegno = loadTexture("modello/textures/Wood_Specular.png");
            var diffuseMapLegno = loadTexture("modello/textures/Wood_Diffuse.png");
            var roughnessMapLegno = loadTexture("modello/textures/Wood_Roughness.png");

//------------------------------------------ background
			var loader = new THREE.CubeTextureLoader();
            loader.setPath( 'cubemap/jungle2/' );
            var textureCube = loader.load( [
                'px.jpg', 'nx.jpg',
                'py.jpg', 'ny.jpg',
                'pz.jpg', 'nz.jpg'
            ] );


            loader.setPath( 'cubemap/jungle2Irradiance/' );
			var irradianceMap = loader.load( [
					'px.jpg', 'nx.jpg',
					'py.jpg', 'ny.jpg',
					'pz.jpg', 'nz.jpg'
			] );



            loader.setPath( 'cubemap/tempio/' );
            var textureCube1 = loader.load( [
                'px.jpg', 'nx.jpg',
                'py.jpg', 'ny.jpg',
                'pz.jpg', 'nz.jpg'
            ] );


            loader.setPath( 'cubemap/tempioIrradiance/' );
			var irradianceMap1 = loader.load( [
					'px.jpg', 'nx.jpg',
					'py.jpg', 'ny.jpg',
					'pz.jpg', 'nz.jpg'
			] );



            loader.setPath( 'cubemap/Yokohama/' );
            var textureCube2 = loader.load( [
                'px.jpg', 'nx.jpg',
                'py.jpg', 'ny.jpg',
                'pz.jpg', 'nz.jpg'
            ] );


            loader.setPath( 'cubemap/YokohamaIrradiance/' );
			var irradianceMap2 = loader.load( [
					'px.jpg', 'nx.jpg',
					'py.jpg', 'ny.jpg',
					'pz.jpg', 'nz.jpg'
			] );



            loader.setPath( 'cubemap/distesa/' );
            var textureCube3 = loader.load( [
                'px.jpg', 'nx.jpg',
                'py.jpg', 'ny.jpg',
                'pz.jpg', 'nz.jpg'
            ] );


            loader.setPath( 'cubemap/distesaIrradiance/' );
			var irradianceMap3 = loader.load( [
					'px.jpg', 'nx.jpg',
					'py.jpg', 'ny.jpg',
					'pz.jpg', 'nz.jpg'
			] );


         

            loader.setPath( 'cubemap/neve/' );
            var textureCube4 = loader.load( [
                'px.jpg', 'nx.jpg',
                'py.jpg', 'ny.jpg',
                'pz.jpg', 'nz.jpg'
            ] );


            loader.setPath( 'cubemap/neveIrradiance/' );
			var irradianceMap4 = loader.load( [
					'px.jpg', 'nx.jpg',
					'py.jpg', 'ny.jpg',
					'pz.jpg', 'nz.jpg'
			] );

            scene.background = textureCube1;

//------------------------------------------end background

            var uniformsOro = {
                    cspec:  { type: "v3", value: new THREE.Vector3(1.022,0.782,0.344) },
                    cdiff:  { type: "v3", value: new THREE.Vector3(0.0,0.0,0.0) },
                    roughness: {type: "f", value: 0.5},
                    normalMap:  { type: "t", value: normalMapL},
                    normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
                    pointLightPosition: { type: "v3", value: new THREE.Vector3() },
                    clight: { type: "v3", value: new THREE.Vector3() },
                    envMap: { type: "t", value: textureCube1},
                    };


             var uniformsSmeraldo = {
                    cspec:  { type: "v3", value: new THREE.Vector3(0.04,0.496791,0.449419) },
                    cdiff:  { type: "v3", value: new THREE.Vector3(0.0,0.0,0.0) },
                    roughness: {type: "f", value: 0.5},
                    normalMap:  { type: "t", value: normalMapL},
                    normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
                    pointLightPosition: { type: "v3", value: new THREE.Vector3() },
                    clight: { type: "v3", value: new THREE.Vector3() },
                    envMap: { type: "t", value: textureCube1},
                    };


             var uniformsArgento = {
                    cspec:  { type: "v3", value: new THREE.Vector3(0.972,0.960,0.915) },
                    cdiff:  { type: "v3", value: new THREE.Vector3(0.0,0.0,0.0) },
                    roughness: {type: "f", value: 0.5},
                    normalMap:  { type: "t", value: normalMapL},
                    normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
                    pointLightPosition: { type: "v3", value: new THREE.Vector3() },
                    clight: { type: "v3", value: new THREE.Vector3() },
                    envMap: { type: "t", value: textureCube1},
                    };


            var uniformsVetro = {
                    cspec:  { type: "v3", value: new THREE.Vector3(0.5,0.5,0.5) },
                    cdiff:  { type: "v3", value: new THREE.Vector3(0.0,0.0,0.0) },
                    roughness: {type: "f", value: 0.5},
                    normalMap:  { type: "t", value: normalMapL},
                    normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
                    pointLightPosition: { type: "v3", value: new THREE.Vector3() },
                    clight: { type: "v3", value: new THREE.Vector3() },
                    envMap: { type: "t", value: textureCube1},
                    };


             var uniformsTitanio = {
                    cspec:  { type: "v3", value: new THREE.Vector3(0.541931,0.496791,0.449419) },
                    cdiff:  { type: "v3", value: new THREE.Vector3(0.0,0.0,0.0) },
                    roughness: {type: "f", value: 0.5},
                    normalMap:  { type: "t", value: normalMapI},
                    normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
                    pointLightPosition: { type: "v3", value: new THREE.Vector3() },
                    clight: { type: "v3", value: new THREE.Vector3() },
                    envMap: { type: "t", value: textureCube1},
                    irradianceMap:	{ type: "t", value: irradianceMap1},
                    };

             var uniformsRame = {
                    cspec:  { type: "v3", value: new THREE.Vector3(0.955,0.638,0.538) },
                    cdiff:  { type: "v3", value: new THREE.Vector3(0.0,0.0,0.0) },
                    roughness: {type: "f", value: 0.5},
                    normalMap:  { type: "t", value: normalMapI},
                    normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
                    pointLightPosition: { type: "v3", value: new THREE.Vector3() },
                    clight: { type: "v3", value: new THREE.Vector3() },
                    envMap: { type: "t", value: textureCube1},
                    irradianceMap:	{ type: "t", value: irradianceMap1},
                    };


             var uniformsLegno = {
                        specularMap: { type: "t", value: specularMapLegno},
                        diffuseMap: { type: "t", value: diffuseMapLegno},
                        roughnessMap:   { type: "t", value: roughnessMapLegno},
                        pointLightPosition: { type: "v3", value: new THREE.Vector3() },
                        clight: { type: "v3", value: new THREE.Vector3() },
                        textureRepeat: { type: "v2", value: new THREE.Vector2(1,1) },
                        normalMap:  { type: "t", value: normalMapI},
                        normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
                        envMap: { type: "t", value: textureCube1},
                        irradianceMap:	{ type: "t", value: irradianceMap1},
                    };


            var uniformsCarbonioTexture = {
                        specularMap: { type: "t", value: specularMapLegno},
                        diffuseMap: { type: "t", value: diffuseMapLegno},
                        roughnessMap:   { type: "t", value: roughnessMapLegno},
                        pointLightPosition: { type: "v3", value: new THREE.Vector3() },
                        clight: { type: "v3", value: new THREE.Vector3() },
                        textureRepeat: { type: "v2", value: new THREE.Vector2(1,1) },
                        normalMap:  { type: "t", value: normalMapI},
                        normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
                        envMap: { type: "t", value: textureCube1},
                        irradianceMap:	{ type: "t", value: irradianceMap1},
                    };


             var uniformsCarbonio = {
                    cspec:  { type: "v3", value: new THREE.Vector3(0.04,0.04,0.04) },
                    cdiff:  { type: "v3", value: new THREE.Vector3(0.0,0.0,0.0) },
                    roughness: {type: "f", value: 0.5},
                    normalMap:  { type: "t", value: normalMapI},
                    normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
                    pointLightPosition: { type: "v3", value: new THREE.Vector3() },
                    clight: { type: "v3", value: new THREE.Vector3() },
                    envMap: { type: "t", value: textureCube1},
                    irradianceMap:	{ type: "t", value: irradianceMap1},
                    };

            materialExtensions = {
                shaderTextureLOD: true // set to use shader texture LOD
            };

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            var uniformsL = uniformsArgento;
            var uniformsI = uniformsRame;
            var environment = textureCube1;
            var irradiance = irradianceMap1;
            var defaultamb = false;

            vs = document.getElementById("vertex").textContent;
            fs = document.getElementById("fragment").textContent;

            fs_vetro = document.getElementById("fragment_vetro").textContent;

            vs_back = document.getElementById("vertex_background").textContent;
            fs_back = document.getElementById("fragment_background").textContent;

            vs_legno = document.getElementById("vertex_irr").textContent;
            fs_legno = document.getElementById("fragment_irr").textContent;

            vs_back_legno = document.getElementById("vertex_legno").textContent;
            fs_back_legno = document.getElementById("fragment_legno").textContent;

            var lamaMaterial = new THREE.ShaderMaterial({ uniforms: uniformsL, vertexShader: vs, fragmentShader: fs });
            lamaMaterial.vertexTangents = true;
            lamaMaterial.needsUpdate = true;
            console.log(lamaMaterial);

            var impugnaturaMaterial = new THREE.ShaderMaterial({ uniforms: uniformsI, vertexShader: vs, fragmentShader: fs });
            impugnaturaMaterial.vertexTangents = true;
            impugnaturaMaterial.needsUpdate = true;
            console.log(impugnaturaMaterial);

            var materialBackL = new THREE.ShaderMaterial({ uniforms: uniformsL, vertexShader: vs_back, fragmentShader: fs_back});
            materialBackL.vertexTangents = true;
            materialBackL.needsUpdate = true;
            console.log(materialBackL);

            var materialBackI = new THREE.ShaderMaterial({ uniforms: uniformsI, vertexShader: vs_back, fragmentShader: fs_back});
            materialBackI.vertexTangents = true;
            materialBackI.needsUpdate = true;
            console.log(materialBackI);
 

            var lightColor_ON_mat = new THREE.MeshBasicMaterial ({color: 0xffff00, wireframe:true});
            var lightColor_OFF_mat = new THREE.MeshBasicMaterial ({color: 0x545454, wireframe:true});
            var lightMesh = new THREE.Mesh( new THREE.SphereGeometry( 1, 16, 16), lightColor_ON_mat );
            lightMesh.position.set( 7.0, 7.0, 7.0 );
            lightMesh.visible = false;
            uniformsL.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
            uniformsI.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);

            var stats = new Stats();

            function loadTexture(file) {
                    var texture = new THREE.TextureLoader().load( file , function ( texture ) {

                        texture.minFilter = THREE.LinearMipMapLinearFilter;
                        texture.anisotropy = renderer.getMaxAnisotropy();
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                        texture.offset.set( 0, 0 );
                        texture.needsUpdate = true;
                        render();
                    } )
                    return texture;
            }

            function init() {
                renderer.setClearColor( 0x1a3300 );

                camera.position.set( 0, 0, 10 );
                scene.add( camera );

                container.appendChild( renderer.domElement );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( larghezza, altezza );

                caricaNuovoModello();

                //controls.addEventListener( 'change', render );
                controls.minDistance = 6;
                controls.maxDistance = 20;
                controls.enablePan = false;
                controls.update();

                window.addEventListener( 'resize', onResize, false );

                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                document.body.appendChild( stats.domElement );


                }

            function onResize() {
                renderer.setSize( larghezza, altezza );
                camera.aspect = ( larghezza / altezza );
                camera.updateProjectionMatrix();
            }

            function update() {
                muoviLuce();
                requestAnimationFrame( update );
                stats.update();
                render();
            }

            function muoviLuce() {
                if(Date.now()>=(movimento_luce_lastUpdate+refreshTime)) {
                        angololuce=angololuce+variazioneAngoloLuce;
                        lightMesh.position.set(40*Math.cos(angololuce*Math.PI/180), 7, -40*Math.sin(angololuce*Math.PI/180));
                        movimento_luce_lastUpdate=Date.now();

                        uniformsL.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
                        uniformsI.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
                    }
            }

            function changeLight(mode) {
                switch(mode){
                    case 'noLight':
                        lightParameters.intensity = 0.0;
                        lightMesh.material = lightColor_OFF_mat;
                        break;
                    case 'yesLight':
                        lightParameters.intensity = 1.0;
                        lightMesh.material = lightColor_ON_mat;
                        break;
                    case 'turnLight':
                        if(variazioneAngoloLuce > 0) {
                            variazioneAngoloLuce = 0.0;
                        } else {
                            variazioneAngoloLuce = 0.5;
                        }
                        break;
                    default:
                        break;
                }
            }

            function render() {
                updateUniforms();
                renderer.render( scene, camera );
            }


            function updateUniforms() {
                uniformsL.clight.value = new THREE.Vector3( lightParameters.red * lightParameters.intensity, lightParameters.green * lightParameters.intensity, lightParameters.blue * lightParameters.intensity);
                uniformsL.normalScale.value = new THREE.Vector2( textureParameters.normalScale, textureParameters.normalScale );
                uniformsI.clight.value = new THREE.Vector3( lightParameters.red * lightParameters.intensity, lightParameters.green * lightParameters.intensity, lightParameters.blue * lightParameters.intensity);
                uniformsI.normalScale.value = new THREE.Vector2( textureParameters.normalScale, textureParameters.normalScale );

            }

            function changeMaterial(materiale) {
            	switch(materiale){
            		case 'oro':
            			uniformsOro.envMap.value = environment;
                        uniformsL = uniformsOro;
            			lamaMaterial = new THREE.ShaderMaterial({ uniforms: uniformsL, vertexShader: vs, fragmentShader: fs });
            			materialBackL = new THREE.ShaderMaterial({uniforms:uniformsL, vertexShader:vs_back, fragmentShader: fs_back});
            			prezzoLama=100;
                        document.getElementById("mat_lama").textContent="oro";
                        document.getElementById("prezzo").textContent=(prezzoLama+prezzoBastone).toString();
            			rimuoviModello();
            			caricaNuovoModello();
            			break;
            		case 'argento':
                      	uniformsArgento.envMap.value = environment;
            			uniformsL = uniformsArgento;
            			lamaMaterial = new THREE.ShaderMaterial({ uniforms: uniformsL, vertexShader: vs, fragmentShader: fs });
            			materialBackL = new THREE.ShaderMaterial({uniforms:uniformsL, vertexShader:vs_back, fragmentShader: fs_back});
            			prezzoLama=80;
            			document.getElementById("mat_lama").textContent="argento";
            			document.getElementById("prezzo").textContent=(prezzoLama+prezzoBastone).toString();
            			rimuoviModello();
            			caricaNuovoModello();
            			break;
            		case 'smeraldo':
                    	uniformsSmeraldo.envMap.value = environment;
            			uniformsL = uniformsSmeraldo;
            			lamaMaterial = new THREE.ShaderMaterial({ uniforms: uniformsL, vertexShader: vs, fragmentShader: fs });
            			materialBackL = new THREE.ShaderMaterial({uniforms:uniformsL, vertexShader:vs_back, fragmentShader: fs_back});
            			prezzoLama=50;
            			document.getElementById("mat_lama").textContent="smeraldo";
            			document.getElementById("prezzo").textContent=(prezzoLama+prezzoBastone).toString();
            			rimuoviModello();
            			caricaNuovoModello();
            			break;
                    case 'vetro':
                        uniformsVetro.envMap.value = environment;
                        uniformsL = uniformsVetro;
                        lamaMaterial = new THREE.ShaderMaterial({ uniforms: uniformsL, vertexShader: vs, fragmentShader: fs_vetro, extensions: materialExtensions });
                        materialBackL = new THREE.ShaderMaterial({uniforms:uniformsL, vertexShader:vs_back, fragmentShader: fs_back});
                        prezzoLama=50;
                        document.getElementById("mat_lama").textContent="vetro";
                        document.getElementById("prezzo").textContent=(prezzoLama+prezzoBastone).toString();
                        rimuoviModello();
                        caricaNuovoModello();
                        break;
            		case 'titanio':
                    	uniformsTitanio.envMap.value = environment;
            			uniformsI = uniformsTitanio;
            			impugnaturaMaterial = new THREE.ShaderMaterial({ uniforms: uniformsI, vertexShader: vs, fragmentShader: fs });
            			materialBackI = new THREE.ShaderMaterial({uniforms:uniformsI, vertexShader:vs_back, fragmentShader: fs_back});
                        prezzoBastone=62;
                        document.getElementById("mat_manico").textContent="titanio";
                        document.getElementById("prezzo").textContent=(prezzoLama+prezzoBastone).toString();
            			rimuoviModello();
            			caricaNuovoModello();
            			break;	
                    case 'rame':
                    	uniformsRame.envMap.value = environment;
            			uniformsI = uniformsRame;
            			impugnaturaMaterial = new THREE.ShaderMaterial({ uniforms: uniformsI, vertexShader: vs, fragmentShader: fs });
            			materialBackI = new THREE.ShaderMaterial({uniforms:uniformsI, vertexShader:vs_back, fragmentShader: fs_back});
                        prezzoBastone=62;
                        document.getElementById("mat_manico").textContent="rame";
                        document.getElementById("prezzo").textContent=(prezzoLama+prezzoBastone).toString();
            			rimuoviModello();
            			caricaNuovoModello();
            			break;	
            		case 'carbonio':
                    	uniformsCarbonio.envMap.value = environment;
            			uniformsI = uniformsCarbonio;
            			impugnaturaMaterial = new THREE.ShaderMaterial({ uniforms: uniformsI, vertexShader: vs, fragmentShader: fs });
            			materialBackI = new THREE.ShaderMaterial({uniforms:uniformsI, vertexShader:vs_back, fragmentShader: fs_back});
						prezzoBastone=42;
            			document.getElementById("mat_manico").textContent="carbonio";
            			document.getElementById("prezzo").textContent=(prezzoLama+prezzoBastone).toString();
            			rimuoviModello();
            			caricaNuovoModello();
            			break;	
            		case 'legno':
                      	uniformsLegno.envMap.value = environment;
                      	uniformsLegno.irradianceMap.value = irradiance;
            			uniformsI = uniformsLegno;
            			impugnaturaMaterial = new THREE.ShaderMaterial({ uniforms: uniformsI, vertexShader: vs_legno, fragmentShader: fs_legno });
            			materialBackI = new THREE.ShaderMaterial({uniforms:uniformsI, vertexShader:vs_back_legno, fragmentShader: fs_back_legno});
                        prezzoBastone=42;
                        document.getElementById("mat_manico").textContent="legno";
                        document.getElementById("prezzo").textContent=(prezzoLama+prezzoBastone).toString();
                        rimuoviModello();
                        caricaNuovoModello();
            			break;
            		default:
            			break;
            	}
            }




            function changeAmbiente(ambiente){
                switch(ambiente){
                    case 'jungle2':
                    	defaultamb = false;
                        environment = textureCube;
                        irradiance = irradianceMap;
                        scene.background = textureCube;
                        uniformsL.envMap.value = textureCube;
                        uniformsI.envMap.value = textureCube;
                        uniformsI.irradianceMap.value = irradianceMap;
                        rimuoviModello();
                        caricaNuovoModello();
                        lightMesh.visible = false;
                        break;
                    case 'tempio':
                    	defaultamb = false;
                        environment = textureCube1;
                        irradiance = irradianceMap1;
                        scene.background = textureCube1;
                        uniformsL.envMap.value = textureCube1;
                        uniformsI.envMap.value = textureCube1;
                        uniformsI.irradianceMap.value = irradianceMap1;
                        rimuoviModello();
                        caricaNuovoModello();
                        lightMesh.visible = false;
                        break;
                    case 'park':
                    	defaultamb = false;
                        environment = textureCube2;
                        irradiance = irradianceMap2;
                        scene.background = textureCube2;
                        uniformsL.envMap.value = textureCube2;
                        uniformsI.envMap.value = textureCube2;
                        uniformsI.irradianceMap.value = irradianceMap2;
                        rimuoviModello();
                        caricaNuovoModello();
                        lightMesh.visible = false;
                        break;
                    case 'distesa':
                    	defaultamb = false;
                        environment = textureCube3;
                        irradiance = irradianceMap3;
                        scene.background = textureCube3;
                        uniformsL.envMap.value = textureCube3;
                        uniformsI.envMap.value = textureCube3;
                        uniformsI.irradianceMap.value = irradianceMap3;
                        rimuoviModello();
                        caricaNuovoModello();
                        lightMesh.visible = false;
                        break;
                    case 'neve':
                        defaultamb = false;
                        environment = textureCube4;
                        irradiance = irradianceMap4;
                        scene.background = textureCube4;
                        uniformsL.envMap.value = textureCube4;
                        uniformsI.envMap.value = textureCube4;
                        uniformsI.irradianceMap.value = irradianceMap4;
                        rimuoviModello();
                        caricaNuovoModello();
                        lightMesh.visible = false;
                        break;
                    case 'noBack':
                    	defaultamb = true;
            			rimuoviModello();
                        scene.background =  0x1a3300;
                        caricaNuovoModello();
                        lightMesh.visible = true;
                        break;      
                }   
            }




            function caricaNuovoModello(){
				var loader = new THREE.OBJLoader2();
            	loader.useIndices = true;

                loader.load( "modello/source/ascia.obj", function ( obj ) {
                    //console.log(obj);

                    geometry = obj.detail.loaderRootNode.children[0].geometry;
                    geometry.applyMatrix( new THREE.Matrix4().makeTranslation(115, 0, 0) );
                    var mesh;
                    if (defaultamb == true){
                    	mesh = new THREE.Mesh( geometry, materialBackL );
                    } else {
                    	mesh = new THREE.Mesh( geometry, lamaMaterial );
                    }
                    mesh.scale.multiplyScalar( 0.03 );
                    THREE.BufferGeometryUtils.computeTangents(geometry);
                    scene.add( mesh );

                    geometry = obj.detail.loaderRootNode.children[1].geometry;
                    geometry.applyMatrix( new THREE.Matrix4().makeTranslation(115, 0, 0) );
                    if (defaultamb == true){
                    	mesh = new THREE.Mesh( geometry, materialBackI );
                    } else {
                    	mesh = new THREE.Mesh( geometry, impugnaturaMaterial );
                    }
                    mesh.scale.multiplyScalar( 0.03 );
                    THREE.BufferGeometryUtils.computeTangents(geometry);
                    scene.add( mesh );
                    scene.add(lightMesh);
                } );
			}
			
			function rimuoviModello(){
                while(scene.children.length > 0){ 
                    scene.remove(scene.children[0]); 
                }
			}

            init();
            update();
            render();

        </script>





    <div>
        <div class="buy-section">
        	<p>TUA A SOLI <span id="prezzo">142</span></p>
            <a href="#"><img src="images/buyNow.png" alt="Compra adesso" width="300"></a>
            <p class="description">Spedizione standard gratuita tramite UDP - Spedizione assicurata tramite TCP (+ 4.50).</p>
        </div>
        <div class="footer">
            <p>Come arma per lo scontro ravvicinato, i Mongoli usavano scimitarre, lance e alabarde.<br />
                Esse consentivano colpi di taglio di enormi proporzioni,
                ma niente  paragonabile alla leggendaria ascia di Gengis Khan!<br />
                Caratterizzata da una lama affilata come un rasoio e una struttura pressoch indistruttibile,
                l'ascia da battaglia  una delle armi pi letali al mondo!
                <br />NON PERDERE L'OCCASIONE DI AVERNE UNA NEL TUO SALOTTO DI CASA!
                <p align="center"><img src="images/gengis.png" width="40%"></p>
            </p>
        	
        </div>
        <div>
            <p class="fondo">ACME Industries SDZ, Via delle Scienze 206, Udine. tel +39 0432 555555 fax +39 0432 5550123 mail: acmeind@uniud.it</p>
            <p>&nbsp;</p>
        </div>
    </div>


</div>
</body>

</html> 