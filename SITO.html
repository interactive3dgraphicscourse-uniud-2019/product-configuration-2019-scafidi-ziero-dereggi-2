<!DOCTYPE html>
<html>
<head>
    <title>Scafidi-Ziero-De Reggi: Survivor Blades</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="css/bootstrap.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" media="screen" href="css/main.css">

    <script src="libs/three.js"></script>
    <script src="libs/stats.min.js"></script>
    <script src="libs/OrbitControls.js"></script>
    <script src='libs/dat.gui.min.js'></script>
    <script src='libs/LoaderSupport.js'></script>
    <script src='libs/OBJLoader2.js'></script>

    <script src='libs/BufferGeometryUtils.js'></script>

</head>



<body>
    <div id="container">
        
      <div>
                <div class="row">
                    <div class="col-1">
                        <img id="uniud" src="images/Uniud.png" width="100%" alt="Logo UNIUD">
                    </div>
                    <div class="col-10">
                        <p class="header">...dall'antica tradizione orientale</p>
                        <p class="title">L'ASCIA DI GENGIS KHAN</p>
                    </div>
                    <div class="col-1">
                        <img id="uniud" src="images/acme_logo.png" width="100%" alt="Logo UNIUD">
                    </div>
                </div>
      </div>

        <div class="row justify-content-md-center">
            <div class="col-2">
                <p class="menuchoice">Modifica il MATERIALE della lama</p>
                    <a href="#" onClick="changeMaterial('argento')"><img class="material" src="images/metal.jpg" alt="argento"></a>
                    <a href="#" onClick="changeMaterial('oro')"><img class="material" src="images/oro.jpg" alt="oro"></a>
                    <a href="#" onClick="changeMaterial('carbone')"><img class="material" src="images/carbon.jpg" alt="carbone"></a>
                <p class="menuchoice">Modifica MATERIALE dell'impugnatura</p>
                    <a href="#" onClick="changeMaterial('carbone1')"><img class="material" src="images/hardPlastic.jpg" alt="hardPlastic"></a>
                    <a href="#" onClick="changeMaterial('argento1')"><img class="material" src="images/legno.jpg" alt="legno"></a>
                    <a href="#" onClick="changeMaterial('oro1')"><img class="material" src="images/gomma.jpg" alt="gomma"></a>
            </div>


            <div class="col-8 h-100">
                <div style="height: 500px;" id="canvas"></div>
            </div>


            <div class="col-2">
                <p class="menuchoice">Modifica il BACKGROUND</p>
                    <a href="#" onClick="changeAmbiente('jungle2')"><img class="material" src="images/jungle2.jpg" alt="jungle2"></a>
                    <a href="#" onClick="changeAmbiente('park')"><img class="material" src="images/park.jpg" alt="park"></a>
                    <a href="#" onClick="changeAmbiente('tempio')"><img class="material" src="images/tempio.jpg" alt="tempio"></a>
                    <a href="#" onClick="changeAmbiente('distesa')"><img class="material" src="images/distesa.jpg" alt="distesa"></a>
                    <a href="#" onClick="changeAmbiente('neve')"><img class="material" src="images/neve.jpg" alt="neve"></a>
                    <a href="#" onClick="changeAmbiente('noBack')"><img class="material" src="images/noBack.jpg" alt="noBack"></a>
                <p>&nbsp;</p>
                <p class="menuchoice">Controllo LUCE</p>
                    <a href="#" onClick="changeLight('noLight')"><img class="icona" src="images/icona_luce_off.png" alt="noLight"></a>
                    <a href="#" onClick="changeLight('yesLight')"><img class="icona" src="images/icona_luce.png" alt="yesLight"></a>
                    <a href="#" onClick="changeLight('turnLight')"><img class="icona" src="images/icona_luce_gira.png" alt="turnLight"></a>
            </div>
        </div>



		<script type="text/x-glsl" id="vertex_background">
        attribute vec4 tangent;
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec2 vUv;
        varying vec3 vTangent;
        varying vec3 vBitangent;

        void main() {
            vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
            vPosition = vPos.xyz;
            vNormal = normalize(normalMatrix * normal);
            vec3 objectTangent = vec3( tangent.xyz );
            vec3 transformedTangent = normalMatrix * objectTangent;
            vTangent = normalize( transformedTangent );
            vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
            vUv = uv;
            gl_Position = projectionMatrix * vPos;
        }
        </script>

        <script type="text/x-glsl" id="fragment_background">
            varying vec3 vNormal;
            varying vec3 vTangent;
            varying vec3 vBitangent;
            varying vec3 vPosition;
            varying vec2 vUv;
            uniform vec3 pointLightPosition; // in world space
            uniform vec3 clight;
            uniform vec3 cspec;
            uniform vec3 cdiff;
            uniform float roughness;
            uniform sampler2D normalMap;
            uniform vec2 normalScale;
            const float PI = 3.14159;

            vec3 FSchlick(float lDoth) {
                return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
            }

            float DGGX(float nDoth, float alpha) {
                float alpha2 = alpha*alpha;
                float d = nDoth*nDoth*(alpha2-1.0)+1.0;
                return (  alpha2 / (PI*d*d));
            }

            float G1(float dotProduct, float k) {
                return (dotProduct / (dotProduct*(1.0-k) + k) );
            }

            float GSmith(float nDotv, float nDotl) {
                    float k = roughness*roughness;
                    return G1(nDotl,k)*G1(nDotv,k);
            }


            void main() {
                vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
                vec3 l = normalize(lPosition.xyz - vPosition.xyz);
                vec3 normal = normalize( vNormal );
                vec3 tangent = normalize( vTangent );
                vec3 bitangent = normalize( vBitangent );
                mat3 vTBN = mat3( tangent, bitangent, normal );
                vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
                //mapN.xy = normalScale * mapN.xy;
                vec3 n = normalize( vTBN * mapN );
                vec3 v = normalize( -vPosition);
                vec3 h = normalize( v + l);
                // small quantity to prevent divisions by 0
                float nDotl = max(dot( n, l ),0.000001);
                float lDoth = max(dot( l, h ),0.000001);
                float nDoth = max(dot( n, h ),0.000001);
                float vDoth = max(dot( v, h ),0.000001);
                float nDotv = max(dot( n, v ),0.000001);
                vec3 fresnel = FSchlick(lDoth);
                vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/
                    (4.0*nDotl*nDotv);
                vec3 outRadiance = PI* clight * nDotl * BRDF;
                // gamma encode the final value
                gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
            }
        </script>



        <script type="text/x-glsl" id="vertex">
        attribute vec4 tangent;
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 wPosition;
        varying vec3 vTangent;
        varying vec3 vBitangent;
        varying vec2 vUv;

        void main() {
            vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
            vPosition = vPos.xyz;
            wPosition = (modelMatrix * vec4( position, 1.0 )).xyz;
            vNormal = normalize(normalMatrix * normal);
            vec3 objectTangent = vec3( tangent.xyz );
            vec3 transformedTangent = normalMatrix * objectTangent;
            vTangent = normalize( transformedTangent );
            vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
            vUv = uv;
            gl_Position = projectionMatrix * vPos;
        }
        </script>

        <script type="text/x-glsl" id="fragment">
            varying vec3 vNormal;
            varying vec3 vTangent;
            varying vec3 vBitangent;
            varying vec3 vPosition;
            varying vec3 wPosition;
            varying vec2 vUv;
            uniform vec3 cspec;
            uniform sampler2D normalMap;
            uniform samplerCube envMap;
            uniform vec2 normalScale;
            const float PI = 3.14159;

            vec3 FSchlick(float lDoth) {
                return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
            }

        

        // http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
        vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
            return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
        }

            void main() {
                vec3 normal = normalize( vNormal );
                vec3 tangent = normalize( vTangent );
                vec3 bitangent = normalize( vBitangent );
                mat3 vTBN = mat3( tangent, bitangent, normal );
                vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
                //mapN.xy = normalScale * mapN.xy;
                vec3 n = normalize( vTBN * mapN );
                vec3 v = normalize( -vPosition);
                vec3 worldN = inverseTransformDirection( n, viewMatrix );
                vec3 worldV = cameraPosition - wPosition ;
                vec3 r = normalize( reflect(-worldV,worldN));
                // small quantity to prevent divisions by 0
                float nDotv = max(dot( n, v ),0.000001);
                vec3 fresnel = FSchlick(nDotv);
                // negate x to account for how cubemap is displayed on background
                vec3 envLight = textureCube( envMap, vec3(-r.x, r.yz)).rgb;
                // texture in sRGB, linearize
                envLight = pow( envLight, vec3(2.2));
                vec3 outRadiance = fresnel*envLight;
                // gamma encode the final value
                gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
            }
        </script>

        


        <script>
            var refreshTime=10; //millisecondi
            var movimento_luce_lastUpdate=0;
            var angololuce=-50;
            var variazioneAngoloLuce = 0;





            container = document.getElementById('canvas');
            larghezza = document.getElementById('canvas').clientWidth -10;
            altezza = document.getElementById('canvas').clientHeight -10;
            console.log("altezza"+altezza);
            console.log("larghezza"+larghezza);
            var renderer = new THREE.WebGLRenderer( { antialias: true } );
            var camera = new THREE.PerspectiveCamera( 35, larghezza / altezza, 1, 1000 );
            var controls = new THREE.OrbitControls( camera, renderer.domElement );
            var scene = new THREE.Scene();

            // default: white, 1.0 intensity
            var lightParameters = {
                red: 1.0,
                green: 1.0,
                blue: 1.0,
                intensity: 1.0,
            }

            var textureParameters = {
                normalScale: 0.0,
            }

            var normalMapI = loadTexture( "modello/textures/Cylinder001 [Normal].png" );
            var normalMapL = loadTexture( "modello/textures/Box002 [Normal].png" );

//------------------------------------------ background
			var loader = new THREE.CubeTextureLoader();
            loader.setPath( 'cubemap/jungle2/' );
            var textureCube = loader.load( [
                'px.jpg', 'nx.jpg',
                'py.jpg', 'ny.jpg',
                'pz.jpg', 'nz.jpg'
            ] );


            var loader = new THREE.CubeTextureLoader();
            loader.setPath( 'cubemap/tempio/' );
            var textureCube1 = loader.load( [
                'px.jpg', 'nx.jpg',
                'py.jpg', 'ny.jpg',
                'pz.jpg', 'nz.jpg'
            ] );

            var loader = new THREE.CubeTextureLoader();
            loader.setPath( 'cubemap/Yokohama/' );
            var textureCube2 = loader.load( [
                'px.jpg', 'nx.jpg',
                'py.jpg', 'ny.jpg',
                'pz.jpg', 'nz.jpg'
            ] );

            var loader = new THREE.CubeTextureLoader();
            loader.setPath( 'cubemap/distesa/' );
            var textureCube3 = loader.load( [
                'px.jpg', 'nx.jpg',
                'py.jpg', 'ny.jpg',
                'pz.jpg', 'nz.jpg'
            ] );

            var loader = new THREE.CubeTextureLoader();
            loader.setPath( 'cubemap/neve/' );
            var textureCube4 = loader.load( [
                'px.jpg', 'nx.jpg',
                'py.jpg', 'ny.jpg',
                'pz.jpg', 'nz.jpg'
            ] );

            scene.background = textureCube1;

//------------------------------------------end background

            var uniformsOro = {
                    cspec:  { type: "v3", value: new THREE.Vector3(1.022,0.782,0.344) },
                    cdiff:  { type: "v3", value: new THREE.Vector3(0.0,0.0,0.0) },
                    roughness: {type: "f", value: 0.5},
                    normalMap:  { type: "t", value: normalMapL},
                    normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
                    pointLightPosition: { type: "v3", value: new THREE.Vector3() },
                    clight: { type: "v3", value: new THREE.Vector3() },
                    envMap: { type: "t", value: textureCube1},
                    };


             var uniformsCarbone = {
                    cspec:  { type: "v3", value: new THREE.Vector3(0.04,0.04,0.04) },
                    cdiff:  { type: "v3", value: new THREE.Vector3(0.04,0.04,0.04) },
                    roughness: {type: "f", value: 0.5},
                    normalMap:  { type: "t", value: normalMapL},
                    normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
                    pointLightPosition: { type: "v3", value: new THREE.Vector3() },
                    clight: { type: "v3", value: new THREE.Vector3() },
                    envMap: { type: "t", value: textureCube1},
                    };


             var uniformsArgento = {
                    cspec:  { type: "v3", value: new THREE.Vector3(0.972,0.960,0.915) },
                    cdiff:  { type: "v3", value: new THREE.Vector3(0.0,0.0,0.0) },
                    roughness: {type: "f", value: 0.5},
                    normalMap:  { type: "t", value: normalMapL},
                    normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
                    pointLightPosition: { type: "v3", value: new THREE.Vector3() },
                    clight: { type: "v3", value: new THREE.Vector3() },
                     envMap: { type: "t", value: textureCube1},
                    };

             var uniformsOro1 = {
                    cspec:  { type: "v3", value: new THREE.Vector3(1.022,0.782,0.344) },
                    cdiff:  { type: "v3", value: new THREE.Vector3(0.0,0.0,0.0) },
                    roughness: {type: "f", value: 0.5},
                    normalMap:  { type: "t", value: normalMapI},
                    normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
                    pointLightPosition: { type: "v3", value: new THREE.Vector3() },
                    clight: { type: "v3", value: new THREE.Vector3() },
                    envMap: { type: "t", value: textureCube1},
                    };


             var uniformsCarbone1 = {
                    cspec:  { type: "v3", value: new THREE.Vector3(0.04,0.04,0.04) },
                    cdiff:  { type: "v3", value: new THREE.Vector3(0.04,0.04,0.04) },
                    roughness: {type: "f", value: 0.5},
                    normalMap:  { type: "t", value: normalMapI},
                    normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
                    pointLightPosition: { type: "v3", value: new THREE.Vector3() },
                    clight: { type: "v3", value: new THREE.Vector3() },
                    envMap: { type: "t", value: textureCube1},
                    };


             var uniformsArgento1 = {
                    cspec:  { type: "v3", value: new THREE.Vector3(0.972,0.960,0.915) },
                    cdiff:  { type: "v3", value: new THREE.Vector3(0.0,0.0,0.0) },
                    roughness: {type: "f", value: 0.5},
                    normalMap:  { type: "t", value: normalMapI},
                    normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
                    pointLightPosition: { type: "v3", value: new THREE.Vector3() },
                    clight: { type: "v3", value: new THREE.Vector3() },
                    envMap: { type: "t", value: textureCube1},
                    };

             


            var uniformsL = uniformsArgento;
            var uniformsI = uniformsOro1;
            var environment = textureCube1;
            var defaultamb = false;

            vs = document.getElementById("vertex").textContent;
            fs = document.getElementById("fragment").textContent;

            vs_back = document.getElementById("vertex_background").textContent;
            fs_back = document.getElementById("fragment_background").textContent;

            var lamaMaterial = new THREE.ShaderMaterial({ uniforms: uniformsL, vertexShader: vs, fragmentShader: fs });
            lamaMaterial.vertexTangents = true;
            lamaMaterial.needsUpdate = true;
            console.log(lamaMaterial);

            var impugnaturaMaterial = new THREE.ShaderMaterial({ uniforms: uniformsI, vertexShader: vs, fragmentShader: fs });
            impugnaturaMaterial.vertexTangents = true;
            impugnaturaMaterial.needsUpdate = true;
            console.log(impugnaturaMaterial);

            var materialBackL = new THREE.ShaderMaterial({ uniforms: uniformsL, vertexShader: vs_back, fragmentShader: fs_back});
            materialBackL.vertexTangents = true;
            materialBackL.needsUpdate = true;
            console.log(materialBackL);

            var materialBackI = new THREE.ShaderMaterial({ uniforms: uniformsI, vertexShader: vs_back, fragmentShader: fs_back});
            materialBackI.vertexTangents = true;
            materialBackI.needsUpdate = true;
            console.log(materialBackI);
 

            var lightColor_ON_mat = new THREE.MeshBasicMaterial ({color: 0xffff00, wireframe:true});
            var lightColor_OFF_mat = new THREE.MeshBasicMaterial ({color: 0x545454, wireframe:true});
            var lightMesh = new THREE.Mesh( new THREE.SphereGeometry( 1, 16, 16), lightColor_ON_mat );
            lightMesh.position.set( 7.0, 7.0, 7.0 );
            lightMesh.visible = false;
            uniformsL.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
            uniformsI.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);

            var stats = new Stats();

            function loadTexture(file) {
                    var texture = new THREE.TextureLoader().load( file , function ( texture ) {

                        texture.minFilter = THREE.LinearMipMapLinearFilter;
                        texture.anisotropy = renderer.getMaxAnisotropy();
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                        texture.offset.set( 0, 0 );
                        texture.needsUpdate = true;
                        render();
                    } )
                    return texture;
            }

            function init() {
                renderer.setClearColor( 0x1a3300 );

                camera.position.set( 0, 0, 15 );
                scene.add( camera );

                container.appendChild( renderer.domElement );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( larghezza, altezza );

                caricaNuovoModello();

                //controls.addEventListener( 'change', render );
                controls.minDistance = 6;
                controls.maxDistance = 20;
                controls.enablePan = false;
                controls.update();

                window.addEventListener( 'resize', onResize, false );

                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                document.body.appendChild( stats.domElement );

                }

            function onResize() {
                renderer.setSize( larghezza, altezza );
                camera.aspect = ( larghezza / altezza );
                camera.updateProjectionMatrix();
            }

            function update() {
                muoviLuce();
                requestAnimationFrame( update );
                stats.update();
                render();
            }

            function muoviLuce() {
                if(Date.now()>=(movimento_luce_lastUpdate+refreshTime)) {
                        angololuce=angololuce+variazioneAngoloLuce;
                        lightMesh.position.set(40*Math.cos(angololuce*Math.PI/180), 7, -40*Math.sin(angololuce*Math.PI/180));
                        movimento_luce_lastUpdate=Date.now();

                        uniformsL.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
                        uniformsI.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
                    }
            }

            function changeLight(mode) {
                switch(mode){
                    case 'noLight':
                        lightParameters.intensity = 0.0;
                        lightMesh.material = lightColor_OFF_mat;
                        break;
                    case 'yesLight':
                        lightParameters.intensity = 1.0;
                        lightMesh.material = lightColor_ON_mat;
                        break;
                    case 'turnLight':
                        if(variazioneAngoloLuce > 0) {
                            variazioneAngoloLuce = 0.0;
                        } else {
                            variazioneAngoloLuce = 0.5;
                        }
                        break;
                    default:
                        break;
                }
            }

            function render() {
                updateUniforms();
                renderer.render( scene, camera );
            }


            function updateUniforms() {
                uniformsL.clight.value = new THREE.Vector3( lightParameters.red * lightParameters.intensity, lightParameters.green * lightParameters.intensity, lightParameters.blue * lightParameters.intensity);
                uniformsL.normalScale.value = new THREE.Vector2( textureParameters.normalScale, textureParameters.normalScale );
                uniformsI.clight.value = new THREE.Vector3( lightParameters.red * lightParameters.intensity, lightParameters.green * lightParameters.intensity, lightParameters.blue * lightParameters.intensity);
                uniformsI.normalScale.value = new THREE.Vector2( textureParameters.normalScale, textureParameters.normalScale );

            }

            function changeMaterial(materiale){
            	switch(materiale){
            		case 'oro':
            			uniformsOro.envMap.value = environment;
                        uniformsL = uniformsOro;
            			lamaMaterial = new THREE.ShaderMaterial({ uniforms: uniformsL, vertexShader: vs, fragmentShader: fs });
            			materialBackL = new THREE.ShaderMaterial({uniforms:uniformsL, vertexShader:vs_back, fragmentShader: fs_back});
            			rimuoviModello();
            			caricaNuovoModello();
            			uniformsL.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
            			uniformsI.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
            			break;
            		case 'argento':
                      	uniformsArgento.envMap.value = environment;
            			uniformsL = uniformsArgento;
            			lamaMaterial = new THREE.ShaderMaterial({ uniforms: uniformsL, vertexShader: vs, fragmentShader: fs });
            			materialBackL = new THREE.ShaderMaterial({uniforms:uniformsL, vertexShader:vs_back, fragmentShader: fs_back});
            			rimuoviModello();
            			caricaNuovoModello();
            			 uniformsL.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
            			 uniformsI.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
            			break;
            		case 'carbone':
                    	uniformsCarbone.envMap.value = environment;
            			uniformsL = uniformsCarbone;
            			lamaMaterial = new THREE.ShaderMaterial({ uniforms: uniformsL, vertexShader: vs, fragmentShader: fs });
            			materialBackL = new THREE.ShaderMaterial({uniforms:uniformsL, vertexShader:vs_back, fragmentShader: fs_back});
            			rimuoviModello();
            			caricaNuovoModello();
            			 uniformsL.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
            			 uniformsI.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
            			break;
            		case 'oro1':
                    	uniformsOro1.envMap.value = environment;
            			uniformsI = uniformsOro1;
            			impugnaturaMaterial = new THREE.ShaderMaterial({ uniforms: uniformsI, vertexShader: vs, fragmentShader: fs });
            			materialBackI = new THREE.ShaderMaterial({uniforms:uniformsI, vertexShader:vs_back, fragmentShader: fs_back});
            			rimuoviModello();
            			caricaNuovoModello();
            			 uniformsI.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
            			 uniformsL.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
            			break;	
            		case 'argento1':
                    	uniformsArgento1.envMap.value = environment;
            			uniformsI = uniformsArgento1;
            			impugnaturaMaterial = new THREE.ShaderMaterial({ uniforms: uniformsI, vertexShader: vs, fragmentShader: fs });
            			materialBackI = new THREE.ShaderMaterial({uniforms:uniformsI, vertexShader:vs_back, fragmentShader: fs_back});
            			rimuoviModello();
            			caricaNuovoModello();
            			uniformsI.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
            			uniformsL.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
            			break;	
            		case 'carbone1':
                      	uniformsCarbone1.envMap.value = environment;
            			uniformsI = uniformsCarbone1;
            			impugnaturaMaterial = new THREE.ShaderMaterial({ uniforms: uniformsI, vertexShader: vs, fragmentShader: fs });
            			materialBackI = new THREE.ShaderMaterial({uniforms:uniformsI, vertexShader:vs_back, fragmentShader: fs_back});
            			rimuoviModello();
            			caricaNuovoModello();
            			 uniformsI.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
            			 uniformsL.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x, lightMesh.position.y, lightMesh.position.z);
            			break;
            		default:
            			break;
            	}
            }




            function changeAmbiente(ambiente){
                switch(ambiente){
                    case 'jungle2':
                    	defaultamb = false;
                        environment = textureCube;
                        scene.background = textureCube;
                        uniformsL.envMap.value = textureCube;
                        uniformsI.envMap.value = textureCube;
                        rimuoviModello();
                        caricaNuovoModello();
                        lightMesh.visible = false;
                        break;
                    case 'tempio':
                    	defaultamb = false;
                        environment = textureCube1;
                        scene.background = textureCube1;
                        uniformsL.envMap.value = textureCube1;
                        uniformsI.envMap.value = textureCube1;
                        rimuoviModello();
                        caricaNuovoModello();
                        lightMesh.visible = false;
                        break;
                    case 'park':
                    	defaultamb = false;
                        environment = textureCube2;
                        scene.background = textureCube2;
                        uniformsL.envMap.value = textureCube2;
                        uniformsI.envMap.value = textureCube2;
                        rimuoviModello();
                        caricaNuovoModello();
                        lightMesh.visible = false;
                        break;
                    case 'distesa':
                    	defaultamb = false;
                        environment = textureCube3;
                        scene.background = textureCube3;
                        uniformsL.envMap.value = textureCube3;
                        uniformsI.envMap.value = textureCube3;
                        rimuoviModello();
                        caricaNuovoModello();
                        lightMesh.visible = false;
                        break;
                    case 'neve':
                        defaultamb = false;
                        environment = textureCube4;
                        scene.background = textureCube4;
                        uniformsL.envMap.value = textureCube4;
                        uniformsI.envMap.value = textureCube4;
                        rimuoviModello();
                        caricaNuovoModello();
                        lightMesh.visible = false;
                        break;
                    case 'noBack':
                    	defaultamb = true;
            			rimuoviModello();
                        scene.background =  0x1a3300;
                        caricaNuovoModello();
                        lightMesh.visible = true;
                        break;      
                }   
            }




            function caricaNuovoModello(){
				var loader = new THREE.OBJLoader2();
            	loader.useIndices = true;

                loader.load( "modello/source/ascia.obj", function ( obj ) {
                    //console.log(obj);

                    geometry = obj.detail.loaderRootNode.children[0].geometry;
                    geometry.applyMatrix( new THREE.Matrix4().makeTranslation(115, 0, 0) );
                    var mesh;
                    if (defaultamb == true){
                    	mesh = new THREE.Mesh( geometry, materialBackL );
                    } else {
                    	mesh = new THREE.Mesh( geometry, lamaMaterial );
                    }
                    mesh.scale.multiplyScalar( 0.03 );
                    THREE.BufferGeometryUtils.computeTangents(geometry);
                    scene.add( mesh );

                    geometry = obj.detail.loaderRootNode.children[1].geometry;
                    geometry.applyMatrix( new THREE.Matrix4().makeTranslation(115, 0, 0) );
                    if (defaultamb == true){
                    	mesh = new THREE.Mesh( geometry, materialBackI );
                    } else {
                    	mesh = new THREE.Mesh( geometry, impugnaturaMaterial );
                    }
                    mesh.scale.multiplyScalar( 0.03 );
                    THREE.BufferGeometryUtils.computeTangents(geometry);
                    scene.add( mesh );
                    scene.add(lightMesh);
                } );
			}
			
			function rimuoviModello(){
                while(scene.children.length > 0){ 
                    scene.remove(scene.children[0]); 
                }
			}

            init();
            update();
            render();

        </script>





    <div>
        <div class="footer">
            <h1>&nbsp;</h1>
            <p>Come arma per lo scontro ravvicinato, i Mongoli usavano scimitarre, lance e alabarde.<br />
                Esse consentivano colpi di taglio di enormi proporzioni,
                ma niente è paragonabile alla leggendaria ascia di Gengis Khan!<br />
                Caratterizzata da una lama affilata come un rasoio e una struttura pressochè indistruttibile,
                l'ascia da battaglia è una delle armi più letali al mondo!
                
                <br />NON PERDERE L'OCCASIONE DI AVERNE UNA NEL TUO SALOTTO DI CASA!
            </p>
        	
        </div>
        <div class="buy-section">
        	<p>TUA A SOLI 162€</p>
           
            <a href="#"><img src="images/buyNow.png" alt="Compra adesso" width="300"></a>
        </div>
        <div>
            <p class="fondo">ACME Industries SDZ, Via delle Scienze 206, Udine. tel +39 0432 555555 fax +39 0432 5550123 mail: acmeind@uniud.it</p>
            <p>&nbsp;</p>
        </div>
    </div>


</div>
</body>

</html> 